var documenterSearchIndex = {"docs":
[{"location":"interface/#Allocator-interface","page":"Allocator interface","title":"Allocator interface","text":"","category":"section"},{"location":"interface/","page":"Allocator interface","title":"Allocator interface","text":"The allocator interface is currently considered experimental and not part of the public API.","category":"page"},{"location":"interface/","page":"Allocator interface","title":"Allocator interface","text":"AllocArrays.Allocator","category":"page"},{"location":"interface/#AllocArrays.Allocator","page":"Allocator interface","title":"AllocArrays.Allocator","text":"abstract type Allocator end\n\nAllocators need to subtype Allocator and implement two methods of alloc_similar:\n\nAllocArrays.alloc_similar(::MyAllocator, a::AllocArray, ::Type{T}, dims::Dims)\nAllocArrays.alloc_similar(::MyAllocator, ::Type{<:AllocArray{T}}, dims::Dims) where {T}\n\nto support AllocArrays, (which should each return an AllocArray) and likewise\n\nAllocArrays.alloc_similar(::MyAllocator, a::CheckedAllocArray, ::Type{T}, dims::Dims)\nAllocArrays.alloc_similar(::MyAllocator, ::Type{<:CheckedAllocArray{T}}, dims::Dims) where {T}\n\nwhich should each return a CheckedAllocArray.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-of-improper-usage","page":"Examples","title":"Examples of improper usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following, we will use our functions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AllocArrays\n\nfunction some_allocating_function(a)\n    b = similar(a)\n    b .= a\n    c = similar(a)\n    c .= a\n    return (; b, c)\nend\n\nfunction basic_reduction(a)\n    (; b, c) = some_allocating_function(a)\n    return sum(b .+ c)\nend","category":"page"},{"location":"examples/#Wrong:-allowing-escapes","page":"Examples","title":"Wrong: allowing escapes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Allocations inside @no_escape must not escape!","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function bad_function_1(a)\n    b = BumperAllocator()\n    output = []\n    with_allocator(b) do\n        result = some_allocating_function(a)\n        push!(output, result.b) # wrong! `b` is escaping `@no_escape`!\n        reset!(b)\n    end\n    return sum(output...)\nend\n\nbad_function_1(CheckedAllocArray([1]))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a corrected version:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function good_function_1(a)\n    b = BumperAllocator()\n\n    # note, we are not inside `with_allocator`, so we are not making buffer-backed memory\n    output = similar(a)\n\n    with_allocator(b) do\n        result = some_allocating_function(a)\n        output .= result.b # OK! we are copying buffer-backed memory into our heap-allocated memory\n        reset!(b)\n    end\n    return sum(output)\nend\n\ngood_function_1(AllocArray([1]))\n","category":"page"},{"location":"examples/#Wrong:-resetting-a-buffer-in-active-use","page":"Examples","title":"Wrong: resetting a buffer in active use","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"function bad_function_2(a)\n    b = BumperAllocator()\n    output = Channel(Inf)\n    with_allocator(b) do\n        @sync for _ = 1:10\n            Threads.@spawn begin\n                scalar = basic_reduction(a)\n                put!(output, scalar)\n                reset!(b) # wrong! we cannot reset here as `b` is being used on other tasks\n            end\n        end\n    end\n    close(output)\n    return sum(collect(output))\nend\n\nbad_function_2(CheckedAllocArray([1]))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a corrected version:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function good_function_2(a)\n    b = BumperAllocator()\n    output = Channel(Inf)\n    with_allocator(b) do\n        @sync for _ = 1:10\n            Threads.@spawn begin\n                scalar = basic_reduction(a)\n                put!(output, scalar)\n            end\n        end\n        reset!(b) # OK! resetting once we no longer need the allocations\n    end\n    close(output)\n    return sum(collect(output))\nend\n\ngood_function_2(AllocArray([1]))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Or, if we need to reset multiple times as we process the data, we could do a serial version:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function good_function_2b(a)\n    b = BumperAllocator()\n    output = Channel(Inf)\n    with_allocator(b) do\n        for _ = 1:10\n            scalar = basic_reduction(a)\n            put!(output, scalar)\n            reset!(b) # OK to reset here! buffer-backed memory is not being used\n        end\n    end\n    close(output)\n    return sum(collect(output))\nend\n\ngood_function_2b(AllocArray([1]))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We could also do something in-between, by launching tasks in batches of n, then resetting the buffer between them. Or we could use multiple buffers.","category":"page"},{"location":"examples/#Wrong:-neglecting-to-reset-the-buffer","page":"Examples","title":"Wrong: neglecting to reset the buffer","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As shown above, we must be careful about when we reset the buffer. However, if we never reset it (analogous to never garbage collecting), we run into another problem which is we will run out memory!","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function bad_function_3(a, N)\n    b = BumperAllocator()\n    output = Channel(Inf)\n    with_allocator(b) do\n        for _ = 1:N # bad! we are going to allocate `N` times without resetting!\n            # if `N` is very large, we will run out of memory.\n            scalar = basic_reduction(a)\n            put!(output, scalar)\n        end\n    end\n    close(output)\n    return sum(collect(output))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This can be fixed by resetting appropriately, as in e.g. good_function_2b above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AllocArrays","category":"page"},{"location":"#AllocArrays","page":"Home","title":"AllocArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API Documentation for AllocArrays. See also the README at that link for more examples and notes.","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#Array-types","page":"Home","title":"Array types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AllocArray\nCheckedAllocArray","category":"page"},{"location":"#AllocArrays.AllocArray","page":"Home","title":"AllocArrays.AllocArray","text":"struct AllocArray{T,N,A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n    arr::A\nend\n\nAllocArray(arr::AbstractArray)\n\nWrapper type which forwards most array methods to the inner array arr, but dispatches similar to special allocation methods.\n\nUse the constructor AllocArray(arr) to construct an AllocArray.\n\nTypically this constructor is only used at the entrypoint of a larger set of code which is expected to use similar based on this input for further allocations. When inside a with_allocator block, similar can be dispatched to a (dynamically-scoped) bump allocator.\n\n\n\n\n\n","category":"type"},{"location":"#AllocArrays.CheckedAllocArray","page":"Home","title":"AllocArrays.CheckedAllocArray","text":"CheckedAllocArray(arr::AbstractArray)\n\n\"Slow but safe\" version of AllocArray.\n\nKeeps track of whether or not its memory is valid. All accesses to the array first check if the memory is still valid, and throw an InvalidMemoryException if not.\n\nIf the array has memory allocated via a BumperAllocator, when the BumperAllocator is reset via reset!, its memory will be marked invalid.\n\nUses locks to ensure concurrency safety to avoid races between deallocating memory on one task (with reset!) while accessing it on another task (e.g. getindex). However, this array is as unsafe as any other to write and read its contents simultaneously with multiple tasks. (i.e. locks are used only to ensure validity of the memory backing the array when the memory is accessed, not to remove data races when using the array as usual).\n\nSee also: AllocArray.\n\n\n\n\n\n","category":"type"},{"location":"#Allocators","page":"Home","title":"Allocators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BumperAllocator\nwith_allocator\nreset!","category":"page"},{"location":"#AllocArrays.BumperAllocator","page":"Home","title":"AllocArrays.BumperAllocator","text":"BumperAllocator(b::Union{AllocBuffer,SlabBuffer})\n\nUse with with_allocator to dispatch similar calls for AllocArrays and CheckedAllocArrays to allocate using the buffer b, an AllocBuffer provided by Bumper.jl.\n\nUses a lock to serialize allocations to the buffer b, which should allow safe concurrent usage.\n\nUsed with reset! to deallocate. Note it is not safe to deallocate while another task may be allocating, except with CheckedAllocArrays which will error appropriately.\n\nSee also: UncheckedBumperAllocator.\n\nExample\n\nusing AllocArrays, Bumper\n\nb = BumperAllocator(AllocBuffer(2^24)) # 16 MiB\ninput = AllocArray([1,2,3])\nc = Channel(Inf)\nwith_allocator(b) do\n    # ...code with may be multithreaded but which must not escape or return newly-allocated AllocArrays...\n    @sync for i = 1:10\n        Threads.@spawn put!(c, sum(input .+ i))\n    end\n    reset!(b) # called outside of threaded region\n    close(c)\nend\nsum(collect(c))\n\n# output\n225\n\n\n\n\n\n","category":"type"},{"location":"#AllocArrays.with_allocator","page":"Home","title":"AllocArrays.with_allocator","text":"with_allocator(f, allocator)\n\nRun f within a dynamic scope such that similar calls to AllocArrays and CheckedAllocArrays dispatch to allocator allocator.\n\nUsed with allocators DefaultAllocator, BumperAllocator, and UncheckedBumperAllocator.\n\n\n\n\n\n","category":"function"},{"location":"#AllocArrays.reset!","page":"Home","title":"AllocArrays.reset!","text":"reset!(B::UncheckedBumperAllocator)\n\nResets the UncheckedBumperAllocator, deallocating all of the arrays created by it.\n\nThis must only be used if those arrays will not be accessed again.\n\nIt is not safe to deallocate on one task while using the allocator to allocate on another task. Therefore this should only be called outside of threaded regions of code.\n\n\n\n\n\nreset!(b::BumperAllocator)\n\nResets the BumperAllocator, deallocating all of the arrays created by it.\n\nThis must only be used if those arrays will not be accessed again. However, CheckedAllocArrays allocated by this allocator will be marked invalid, causing future accesses to them to error, as a safety feature. AllocArrays have no such safety feature, and access to them after reset! is unsafe.\n\nIt is also not safe to deallocate on one task while using the allocator to allocate on another task. Therefore this should only be called outside of threaded regions of code.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"We also provide an unsafe option.","category":"page"},{"location":"","page":"Home","title":"Home","text":"UncheckedBumperAllocator","category":"page"},{"location":"#AllocArrays.UncheckedBumperAllocator","page":"Home","title":"AllocArrays.UncheckedBumperAllocator","text":"UncheckedBumperAllocator(b::Union{AllocBuffer,SlabBuffer,...})\n\nUse with with_allocator to dispatch similar calls for AllocArrays to allocate using the buffer b, an AllocBuffer provided by Bumper.jl.\n\nDoes not support CheckedAllocArray.\n\nThis provides a naive & direct interface to allocating on the buffer with no safety checks or locks.\n\nThis is unsafe to use if multiple tasks may be allocating simultaneously, and using BumperAllocator is recommended in general.\n\nUsed with reset! to deallocate.\n\nSee also: BumperAllocator.\n\nExample\n\nusing AllocArrays, Bumper\n\ninput = AllocArray([1,2,3])\nb = UncheckedBumperAllocator(AllocBuffer(2^24)) # 16 MiB\nwith_allocator(b) do\n    # ...code with must not allocate AllocArrays on multiple tasks via `similar` nor escape or return newly-allocated AllocArrays...\n    ret = sum(input .* 2)\n    reset!(b)\n    return ret\nend\n\n# output\n12\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"AllocArrays.DefaultAllocator","category":"page"},{"location":"#AllocArrays.DefaultAllocator","page":"Home","title":"AllocArrays.DefaultAllocator","text":"DefaultAllocator()\n\nRepresents the default Julia allocator.\n\nUsed to dispatch similar calls for AllocArrays and CheckedAllocArrays to allocate using the the default Julia allocator.\n\nThis allocator is used by default if another one is not used via with_allocator.\n\n\n\n\n\n","category":"type"}]
}
